// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.9;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
contract Ballot 
{
    
    event dubz(address payable winner, uint256 _highestBid);
    address[] permMembers;
    uint256 numOfMembers;
    uint numOfItemsEver = 0;
    string[] storedMessages;
    AuctionItems[] public forSale;
    
    constructor()
    {
        numOfMembers = 0;
    }
    
    struct AuctionItems
    {
        IERC721 nft;
        uint nftId;
        string itemName;
        uint256 auctionPrice;
        uint auctionTime;
        uint auctionID;
        address payable highestBidder;
        uint highestBid;
        address payable auctionCreator;
    }
    
    
    
    function sell(address _nft, uint _nftID, string memory name, uint256 price, uint duration) public returns(uint)
    {
        numOfItemsEver++;
        forSale.push(AuctionItems(IERC721(_nft), _nftID, name, price, ((block.timestamp + duration)), numOfItemsEver, payable(msg.sender), 0, payable(msg.sender)));
        return numOfItemsEver;
    }
    
    function someoneTookADub(uint id) external payable returns(string memory)
    {
        require(msg.sender == forSale[id-1].auctionCreator, "You do not have permission to call this method.");
          if (isAuctionOver(forSale[id-1]) == true)
          {
              if(msg.sender != forSale[id-1].highestBidder)
              {
                forSale[id-1].nft.transferFrom(forSale[id-1].highestBidder, msg.sender, forSale[id-1].nftId);
                forSale[id-1].auctionCreator.transfer(msg.value);
                emit dubz(forSale[id-1].highestBidder, forSale[id-1].highestBid);
                return "transfer successful";
              }
          }
          return "unexpected error";
    }
    
    function addMember(address newUser) public returns (string memory)
    {
        for(uint i = 0; i < permMembers.length; i++)
        {
           if(permMembers[i] == newUser)
           {
               return "This person is already a member";
           }
        }
        permMembers.push(newUser);
        return "Member has been added";
    }
    
    function isAuctionOver(AuctionItems memory over) internal view returns(bool)
    {
       return over.auctionTime-block.timestamp <= 0 ?  true :  false;
    }
    
    function chat(string memory message) public returns (string memory)
    {
        storedMessages.push(message);
        return "Chat Recorded";
    }
    
    function checkBalance(address user) public view returns (uint256)
    {
        return user.balance;
    }
    
    function bid(uint amountBid, uint itemId) public payable returns(string memory)
    {
       if(forSale[itemId-1].auctionTime-block.timestamp <= 0)
       {
           return "Auction has ended";
       }
       if(amountBid < forSale[itemId-1].highestBid)
       {
           return "Bid is too low!";
       }
       if(msg.sender.balance > amountBid && checkBalance(msg.sender) > amountBid)
       {
           forSale[itemId-1].highestBid = amountBid;
           forSale[itemId-1].highestBidder = payable(msg.sender);
           return "You are now the highest bidder";
       }
       return "You Nonce";
    }
}
